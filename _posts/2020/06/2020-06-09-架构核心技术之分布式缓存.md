---
layout: post 
author: oshacker
title: 【架构入门系列】架构核心技术之分布式缓存
category: arch
tags: [arch]
excerpt: 架构入门系列（二）
---


缓存的主要特点是技术比较简单，同时对性能提升也有特别显著的效果，所以在很多地方都会用到缓存。

缓存是架构设计中一个重要的手段，使用缓存需要注意几个关键指标：缓存键集合的大小、缓存空间的大小以及缓存的使用寿命，这三个指标决定了缓存的有效性、缓存的使用效率、缓存实现的效果。

缓存的类型主要有代理缓存、反向代理缓存、CDN缓存和对象缓存几种。

不是所有的数据都适合使用缓存，使用缓存的时候需要注意以下几点：
+ 频繁修改的数据，这类数据使用缓存效果比较差；
+ 没有热点的数据，这类数据缓存的命中率比较差；
+ 数据不一致，因为缓存的数据和数据库的数据是不同步的，可能存在数据不一致的情况，如果业务场景对数据一致性要求非常高，这个时候使用缓存也要注意。
+ 缓存雪崩，当缓存崩溃的时候，可能会导致整个系统的崩溃，这也是使用缓存中要注意的一个事项。

在架构中使用最多的、关注最多的是分布式缓存，分布式缓存最重要的几个技术点是：分布式对象缓存的架构、分布式对象缓存的访问模型以及分布式对象缓存中一个重要的算法——一致性哈希算法。

## 缓存的主要特点

技术简单、性能提升显著、应用场景多。

缓存的第一个特点是技术相对简单，可以很容易地添加到现有的应用中，不需要复杂的架构技术。在现有的系统中使用缓存，系统所受到的影响和所要做出的调整是非常小的，但是使用缓存以后性能提升却非常明显。因此，使用缓存的场景非常多，不仅我们的系统架构中会用到缓存，在整个的计算机体系结构中缓存几乎是无处不在的。

比如，在CPU中就有缓存，在CPU固件里就有cache，当CPU进行计算的时候，它并不总是每次都去内存中读取数据，而是预加载一部分指令和数据到cache里面，也就是CPU的缓存里面，CPU核心计算取的大多数数据其实是CPU缓存中的数据。

再比如，操作系统的文件缓存。操作系统对磁盘进行操作的时候，也会对数据进行缓存，以加快操作系统访问磁盘文件数据的速度。

还有就是数据库的查询缓存，数据库本身也会对一些数据进行缓存。比如对索引的结构B+树进行缓存，对一些热点的数据记录也要进行缓存，以加快应用程序的访问速度。

微博应用系统中，比较常用的有 DNS客户端缓存、HTTP浏览器缓存、HTTP代理和反向代理缓存、CDN缓存以及各种类型的对象缓存，对象缓存常用的比如 Redis、Memcached等等。

## 缓存提高性能的优势

缓存是架构性能优化的最重要的手段，使用缓存来提升系统性能主要有三方面优势：
1. 缓存的数据来自于内存，访问速度快。我们知道数据从内存中读取要比磁盘上读取速度要快得多，所以使用缓存从内存中读取数据会使系统获得更快的响应特性，系统的访问速度会更快，处理速度也会更快。
2. 缓存中存储的数据形式通常是最终的结果形态，减少资源消耗。比如说我们缓存一个网页、一个对象，这些数据通常是我们计算过的结果。从缓存中读取数据跟从磁盘中或者数据库中直接读取数据不同，从数据库中读取的数据要进行加工处理，生成我们最终的结果，而从缓存中读取的数据通常都是直接最终的结果。因此，使用缓存中的数据可以减少CPU的资源消耗，不需要进行中间的计算，可以进一步提高响应的特性。
3. 使用缓存可以降低数据库磁盘或网络的负载压力。不需要从外部的IO设备中去读取数据，这些数据直接从本地缓存或内存中读取，减少IO设备的访问压力。我们知道IO设备是最容易出现瓶颈的地方，减少这些设备的访问压力、负载压力，可以更好地提升整个系统的处理能力。

## 缓存数据存储（Hash表）

缓存数据是存储在内存中的，那么如何从内存中快速获取一个数据呢？

缓存使用的数据结构主要是哈希表，我们看一下哈希表实现的机制。哈希表最终的存储形式通常是一个顺序表，也就是一个数组结构，数组结构的特点是在内存中连续存储分配。那么，当我们要在哈希表中存储一个数据的时候，哈希表通常以(key,value)这样的数据结构进行存储的。当我们把(key,value)数据结构存储在一个哈希表中的时候，通常的存储过程大致如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch14.png)

首先，我们拿到(key,value)结构，比如在上图中，key是字符串"abc",value是字符串“hello”，先计算key的哈希值，比如字符串“abc”的hashcode算出来是101这样一个整型值。接下来，计算哈希值101对应的哈希表索引，即将哈希表值101对8取模（8从哪里来的呢？哈希表真正的物理存储是一个数组，上图我们创建的哈希表的长度为8，101对8取模余5，这个5就是数组下标的索引值），我们就可以把（"abc","hello"）存储在下标为5的数组中。这一步是最关键的，通常我们所谓的哈希算法就是指这一步，即如何把一个哈希值放到数组中对应的位置。这个例子我们使用的是余数哈希，实践中最常用的也是余数哈希。

当我们进行数据读取的时候，只要给定key，比如"abc"，还是用这样一个算法，先求它的hashcode值101，然后将该hashcode对8取模。因为数组的长度不变，对8取模后依然是5，那么我们到数字下标为5的位置查找，就可以找到前面存储进去"abc"对应的的value值。

通过哈希表可以使整个存储或检索效率时间复杂度都是O(1)，所以即使存储非常大的几百万上千万的数据量，通过哈希表也可以非常快地进行数据的查找和读写。通过这种手段，缓存可以获得较快的读写访问特性，比数据库中的读写速度要快得多。

## 缓存的关键指标——命中率

影响缓存特性的一个关键指标是缓存的命中率。缓存的主要特点是一次写入多次读出，通过这种手段减少对数据库的使用，尽快从缓存中读取数据，提高性能。所以缓存是否有效主要就看一次写进去的缓存能不能多次读出来，以响应业务的请求，这个判断指标就叫做**缓存的命中率**。

缓存命中率是指查询到正确缓存结果的次数除以总的查询次数。比如十次查询九次都能够得到正确的缓存结果，命中率为90%。

影响缓存命中率的三个主要因素是：缓存键集合大小、内存空间大小、缓存的寿命

### 缓存键集合大小

缓存中的每个对象都是通过缓存键进行识别的，比如（"abc","hello"）中的“abc”就是一个缓存键。键是缓存中唯一的标识符，定位一个对象的唯一方式就是对缓存键进行精确的匹配。

比如我们想缓存每个商品的在线商品信息，就需要使用商品ID作为缓存键。换句话说，缓存键空间是你的应用能够生成的所有键的数量。从统计数据上看，应用生成的唯一键越多，重用的机会就越小。比如根据IP地址缓存天气数据，可能需要40多亿个键，但如果基于国家缓存天气数据，只需要几百个缓存键就够了，全世界也不过几百个国家。

所以要尽可能减少缓存键的数量，键的数量越少，缓存的效率越高。设计缓存的时候要关注缓存键是如何进行设计的，它的整个的集合范围限定在一个既能够高效使用，又可以减少它的数量，这个时候的缓存的性能是最好的。

### 缓存内存空间大小

缓存可以使用的内存空间大小决定了缓存对象的平均大小和缓存对象的数量。因为缓存通常是存储在内存中的，缓存对象可用的内存空间相对来说比较昂贵，而且受到严格限制。

如果想缓存更多的对象，就需要先删除老的对象，再添加新的对象。而这些老的对象被删除掉，就会影响到缓存的命中率，所以物理上缓存空间越大，缓存的对象越多，缓存的命中率也就越高。

### 缓存对象生存时间（缓存寿命）

缓存对象的生存时间称为TTL。对象缓存的时间越长，被重用的可能性就越高。使缓存失效的方法有两种：一是超时失效，一种是清除失效（实时清除）。

超时失效是指在构建缓存（写缓存）时，每个缓存对象都设置一个超时时间，在超时之前访问缓存会返回缓存的数据，一旦超时，缓存就失效了，这时再访问缓存，就会返回空。

实时清除是指当有缓存对象更新时，直接通知缓存将已经被更新了的数据进行清除。清除以后，应用程序下一次访问这个缓存对象键时，就不得不到数据库中去查找，这时就会得到最新的数据，因为更新总是更新在数据库里的。

此外，还有一种虽然在时间上没有失效，但是新的对象要写入缓存，而内存空间不够了，这时就需要将一些老的缓存对象清理掉，为新的缓存对象腾出空间。内存空间清除主要使用的算法是LRU算法，最近最久未使用，即清除那些最近最久没有被访问过的对象。

>LRU算法使用链表结构实现，所有的缓存对象都放在同一个链表上。当一个对象被访问时，就把这个对象移到整个链表的头部。当需要清除那些最近最久未使用的对象时，只需要从队列尾部进行查找，越是在队列尾部的，越是最近最久没有被访问过的，即优先清除的，腾出的内存空间让新对象加入进来。

## 缓存的主要类型

### 代理缓存

代理缓存是对客户端的代理，它的主要作用是代理客户端访问互联网。同时因为它代理了所有的客户端HTTP请求，所以它可以进行页面缓存，如果有一些其他的客户端已经访问过这个网页，当新的客户端连接时，就可以将代理缓存中的数据直接返回，避免对数据中心的访问，如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch15.png)

代理缓存是存在客户端一端的缓存，我们无法进行管理，所以代理缓存虽然存在，但是通常不作为我们系统架构中的一部分，我们能够管理的是反向代理缓存。

### 反向代理缓存

代理缓存是代理用户上网的，而反向代理是代理数据中心输出的，所以反向代理缓存服务器存在于数据中心，它是数据中心的统一入口，代理整个数据中心其他服务器的应用处理。如下图，用户通过互联网连接到数据中心时，通常连接的是一个反向代理服务器，反向代理服务器根据用户的请求，在本地的反向代理缓存中查找是否有用户请求的数据，如果有就直接返回这个数据，如果没有再把这个请求向下继续转发，请求后面的应用服务器去处理生成数据。

![](https://www.coderap.cn/assets/images/2020/06/arch16.png)

反向代理缓存可以以多层反向代理缓存的形式出现，因为我们的应用服务器也是经过分层的，在处理的前端通常是一个前端服务器，后面有web服务器，再后面还有应用服务器，再后面还有其他的各类服务器。在这样一个分层的服务器结构里，我们可以对每一层的服务器都进行反向代理缓存。如下图所示，前端web服务器和web服务器分为两层，用户请求接入时，先接入前端web服务器，这个时候在前端web服务器可以加一层反向代理服务器，来代理前端web服务器的HTTP请求。如果用户请求的数据已经包含在这个反向代理服务器中，就可以直接返回；如果没有，再把HTTP请求提交给前端web服务器，前端web服务器在处理时会把请求发给后面的web服务器。在web服务器和前端web服务器之间还可以再加一层反向代理服务器，如果前端web服务器请求的数据在这一层反向代理服务器存在，那么这一层反向代理服务器可以直接将数据返还；如果不存在，再将请求下发给web服务器。

![](https://www.coderap.cn/assets/images/2020/06/arch17.png)

通过这样的方式，极大地减少了前端web服务器或web服务器的访问压力，同时提高了系统的响应性能。

### 内容分发网络CDN缓存

所谓的CDN是指在用户请求的前端（尽量前的前端）为用户提供数据服务。CDN并不存在于我们的数据中心，也不存在于用户的访问系统一端，它介于两者之间，作为网络服务商的缓存服务。用户进行互联网访问的时候，需要通过互联网网络服务商提供的网络链接才能连接到数据中心，那么网络服务商就可以在自己提供的网络服务的机房里进行一次缓存操作，提供一次缓存服务，如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch18.png)

客户端第一次访问example.com时，访问数据中心，数据中心返回HTML页面后，客户端解析HTML，HTML里面还有各种js、css、图片等文件，这些静态资源访问的就是CDN服务器。CDN服务器检查自己是否有需要的静态资源，如果有，就立即返回给客户端；如果没有，CDN服务器自己访问数据中心，获得需要的静态资源后，缓存在CDN服务器上，再返回给客户端。

所以CDN缓存也叫作网络访问的“第一跳”，用户请求最先到达的是互联网服务商的机房。在机房里面部署CDN服务器，提供缓存服务。如果CDN中存在用户请求的Web响应内容，那么就可以直接通过CDN进行返回；如果CDN中不存在，那么CDN会把这个请求通过后面的网络连接发到系统的数据中心去。数据中心返回的结果依然是先通过CDN服务器，CDN服务器就可以把数据缓存在自己的本地，供后面的用户请求操作响应。

### 通读缓存

上面降到的代理缓存、反向代理缓存、CDN缓存都是通读缓存，它代理了用户的请求，也就是说，用户在访问数据时，总是要通过通读缓存。当通读缓存中有需要访问的数据时，就直接把这个数据返回；如果没有，再由通读缓存向真正的数据提供者发出请求。这里面重要的一点是客户端连接的是通读缓存，而不是生成响应的原始服务器，客户端并不知道真正的原始服务器在哪里，它不需要连接原始服务器，而是由通读缓存进行代理。

### 旁路缓存

和通读缓存相对应的叫做旁路缓存，前面提到的独立的键值对（key,value）这样的对象缓存就属于旁路缓存。旁路缓存和通读缓存不同，旁路缓存是客户端先访问旁路缓存中是否有自己想要的数据，如果旁路缓存中没有需要的数据，那么客户端自己去访问真正的数据服务提供者，客户端获得数据以后，会自己把这个数据写入旁路缓存中，这样下一次或其他客户端去读取旁路缓存时就可以获得想要的数据了，如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch19.png)

## 各种介质数据访问延迟

在这里我们插入一下各种介质数据访问的延迟，以便对数据的存储、缓存的特性以及数据的访问延迟有一个感性的认识，如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch20.png)

如上图所示，访问本地内存大概需要100ns；使用SSD磁盘进行搜索，大概需要10万ns；数据包在同一个数据中心来回一次的时间，也就是在同一个路由环境里进行一次访问，大概需要50万ns(0.5ms)；使用非SSD磁盘进行一次搜索，大概需要1000万ns(10ms)；按顺序从网络中读取1MB的数据也需要10ms；按顺序从传统的机械磁盘(非SSD磁盘)读取1MB数据，大概需要30ms；跨越大西洋进行一次网络数据传输，一个来回大概需要150ms的时间。其中，1s等于 1000ms，等于10亿ns。

## 合理使用缓存对象

缓存虽然效率非常高，使用起来也非常简单，但缓存并不是无所不能的，使用缓存时需要关注如何合理使用缓存对象。

### 频繁修改的数据

缓存数据是为一次写入多次读取准备的，但如果写入的数据很快就被修改了，数据还没来得及读取就已经失效或更新了，系统的负担就会很重，使用缓存也没有太多的意义。一般说来，数据的读写比例至少在2:1以上，缓存才有意义。

### 没有热点的数据

另一类需要关注的是缓存对象是没有热点的访问数据，上面提到缓存是一次写入多次读取的数据，但如果写入的数据并不会被多次读取，即没有所谓的热点，这时候使用缓存也没有意义。

我们日常使用的数据通常说来都是有热点的，比如说淘宝中那些热门的商品可能会被几百万、几千万次的访问，那些冷门的商品可能一次访问都没有，缓存就缓存那些热门的商品数据；微博中大V们的微博会被几百万、几千万的粉丝访问，他们的微博数据也是有热点的，而那些没有几个粉丝的博主的微博，几乎不会被访问，这些数据是没有热点的，所以缓存存储的就是淘宝上的那些热门的商品，微博上那些大V的微博，他们都是有热点的缓存，这些数据都能实现一次写入多次甚至非常多次的读取，这种缓存就有效果。但有一些业务场景数据是没有热点的，那么这类业务场景就不需要使用缓存。

### 数据不一致与脏读

缓存中的数据是对主从数据库中数据的缓存，所以它有可能和主存储数据库中的数据不一致，这个问题主要是通过失效时间来解决的，也就是说这个业务能够忍受的失效时间内，保持缓存和数据库中的数据不一致，比如说淘宝的商品数据，如果卖家对商品的数据进行了编辑，这个时候可能买家看不到这些被更新过的数据的，可能需要几分钟的时间，比如3min，即在3min内卖家编辑的数据买家是看不到的，但这种延迟通常是可以接受的。

如果某些场景对更新非常敏感，必须要实时看到，这个时候就不能够使用失效时间进行缓存过期处理了，可能需要进行失效通知。当数据库中的数据进行更新时，立即清除缓存中的数据，下次访问这个数据时，缓存必须重新从主数据库中去加载，才能得到最新的数据。

### 缓存雪崩

使用缓存还需要注意的一点是缓存雪崩，因为热点数据主要是从缓存中去读取，而热点数据是数据访问压力最大的一类数据，这些数据都去缓存中读取，极大地降低了数据库的访问压力。数据库整个系统也是在有缓存的情况下进行设计的，数据库的处理能力是强依赖缓存的。如果缓存突然崩溃了，那么所有的访问压力就会传递到数据库上，数据库不能够承受这样的访问压力，可能也会崩溃，数据库崩溃后，应用程序访问不到数据库，请求不断超时，负载压力不断升高，应用程序服务器也会崩溃，最后导致整个网站所有服务器崩溃，这就是缓存雪崩。

这种情况下系统甚至无法启动，因为系统启动后，新的访问压力又过来，依然是那么大，还是会崩溃。这时候重启缓存也是没有用的，因为重启的缓存中是没有数据的。前面提到，对象缓存是通过加载数据库中的数据并写入到缓存中才有数据的，重新启动的缓存没有数据，也就不能够提供数据读取的能力，所以对缓存有重点依赖的系统，需要特别关注系统的可用性。缓存中的部分数据可以到数据库中加载，但如果全部的缓存数据都丢失了，可能导致整个系统都崩溃，特别需要注意。

## 分布式对象缓存

分布式对象缓存是系统架构中比较重要的一部分内容，如下图。所谓分布式对象缓存是指对象缓存以一个分布式集群的方式向外提供服务，多个应用系统使用同一个分布式对象缓存提供的缓存服务。这里的缓存服务器是由多台服务器组成的，共同构成了一个集群对外提供服务。使用分布式对象缓存的一个重要问题是数据进行读写操作时，如果找到正确的缓存服务器进行读写操作。如果第一次写入数据时写入的是A服务器，但进行缓存读操作时访问的是B服务器，就不能够正确地查找到数据，缓存也就没有了效果。那么，如何才能找到正确的缓存服务器呢？

![](https://www.coderap.cn/assets/images/2020/06/arch21.png)

以Memcached服务器集群为例，看一下分布式对象缓存的模型，如下图。

![](https://www.coderap.cn/assets/images/2020/06/arch22.png)

当需要进行分布式缓存访问时，依然是以（key,value）这样的数据结构进行访问，比如上图中的（'BEIJING',DATA）。同时应用程序需要使用分布式对象缓存的客户端SDK程序进行访问，比如Memcached提供的客户端API，客户端API程序会使用自己的路由算法进行路由选择，选择其中的某一台服务器，找到这台服务器的IP地址和端口后，通过通讯模块和相应的服务器进行通信。

因为进行路由选择时使用的是缓存对象的key进行的计算，下一次使用相同的key、相同路由算法进行计算时，算出来的服务器依然还是前面计算出来的那个服务器，所以通过这种方法可以访问到正确的服务器进行数据读写。服务器越多，提供的缓存空间就越大，实现的缓存效果也就越好，通过集群的方式，提供了更多的缓存空间。

那么，路由算法是如何进行服务器选择的？这里的主要算法依然可以使用前面提到的哈希表的路由算法，即取模算法。比如缓存服务器集群中有三台服务器，key的哈希值对3取模得到的余数一定在0、1、2三个数中，那么每个数字都对应着一台服务器，根据这个数字查找对应的服务器IP地址就可以。使用取模算法进行路由计算非常简单，但该算法也有一个问题，就是服务器进行扩容的时候，比如当前缓存服务器集群有3台服务器，如果3台服务器不够用了，需要添加一台服务器，这个时候对3取模就会变成对4取模，导致的后果是以前对3取模的时候写入的数据，对4取模的时候可能就查找不到了。

实际上使用取模算法进行服务器添加，除数的变化会导致和缓存雪崩一样的后果，即前面写入缓存服务器中的缓存数据，在添加了一台服务器后很多数据都找不到了，类似于雪崩，最后会导致整个服务器集群都崩溃。

我们添加服务器的主要目的是提高它的处理能力，但是不正确的操作可能会导致整个集群都失效，解决这个问题的主要手段是一致性哈希算法。

### 一致性哈希算法

一致性哈希和余数哈希不同，一致性哈希首先是构建一个一致性哈希环结构，一致性哈希环的大小是0～2^32-1，实际上就是计算机中无符号整型值的取值范围，这个取值范围的0和最后一个值2^32-1首尾相连，构成了一个一致性哈希环，如下图所示。然后我们对每个服务器的节点取模（求它的哈希值），把这个哈希值放到环上，所有的服务器都取哈希值放到环上，每一次进行服务器查找路由计算的时候，也取key的哈希值，取到哈希值以后把key放到环上，顺时针查找距离它最近的服务器的节点是哪一个，它的路由节点就是哪一个。通过这种方式也可以实现，key不变的情况下找到的总是相同的服务器。这种一致性哈希算法除了可以实现像余数哈希一样的路由效果以外，对服务器的集群扩容效果也非常好。

![](https://www.coderap.cn/assets/images/2020/06/arch23.png)

在一致性哈希环上进行服务器扩容的时候，新增加一个节点不需要改动前面取模算法里的除数（导致最后的取值结果全部混乱），它只需要在哈希环里根据新的服务器节点的名称计算它的哈希值，把哈希值放到这个环上就可以了。放到环上后，它不会影响到原先服务器节点的哈希值，也不会影响到原先服务器在哈希环上的分布，它只会影响到离它最近的服务器，比如上图中NODE3是新加入的服务器，那么它只会影响到NODE1，原先访问NODE1的一部分key会访问到NODE3上，也就是说对缓存的影响是比较小的，它只会影响到缓存里面的一小段。如果缓存中一小部分数据受到了影响，不能够正确的命中，那么可以去数据库中读取，而数据库的压力只要在它的负载能力之内，就不会崩溃，系统就可以正常运行。所以通过一致性哈希算法可以实现缓存服务器的顺利伸缩扩容。

但是一致性哈希算法有个致命的缺陷。我们知道哈希值其实是一个随机值，把一个随机值放到一个环上以后，可能是不均衡的，也就是说某两个服务器可能距离很近，而和其它的服务器距离很远，这个时候就会导致有些服务器的负载压力特别大，有些服务器的负载压力非常小。同时在进行扩容的时候，比如说加入一个节点3，它影响的只是节点1，而我们实际上希望加入一个服务器节点的时候，它能够分摊所有其它服务器的访问压力和数据冲突。

使用上面描述的算法并不能达到这个效果，所以需要对这个算法进行一些改进，改进办法就是使用虚拟节点。也就是说每个服务器节点放入到一致性哈希环上的时候，并不是把真正的服务器的哈希值放到环上，而是将一个服务器节点虚拟成若干个虚拟节点，把这些虚拟节点的哈希值放到环上去。在实践中通常是把一个服务器节点虚拟成200个虚拟节点，然后把200个虚拟节点放到环上。key依然是顺时针的查找距离它最近的虚拟节点，找到虚拟节点以后，根据映射关系找到真正的物理节点。

通过这种手段，第一，可以解决我们刚才提到的负载不均衡的问题，因为有更多的虚拟节点在环上，所以它们之间的距离总体来说大致是相近的。第二，在加入一个新节点的时候，即加入多个虚拟节点，比如200个虚拟节点，那么加入进来以后环上的每个节点都可能会受到影响，从而分摊原先每个服务器的一部分负载。

## 总结

最后，我们总结回顾一下整个关于缓存部分的内容：
1. 缓存的主要优点是实现方法比较简单，同时提升的效果又非常明显，所以缓存是架构性能优化的一个重要手段。
2. 影响缓存的主要指标是缓存命中率。影响命中率的几个关键因素是缓存键集合的大小、缓存空间的大小和缓存对象的存在时间，也就是缓存的寿命。缓存的主要类型有代理缓存、反向代理缓存、CDN缓存，这三类缓存叫作通读缓存。客户端使用通读缓存的时候，不需要知道后面真正的数据存储服务器在哪里，只需要访问通读缓存，由通读缓存去访问真正的数据提供服务器。另一类缓存就是旁路缓存，这类缓存就是我们在系统架构中常用的对象缓存。使用旁路缓存的时候，应用程序一方面需要知道缓存，需要连接缓存服务器，通过缓存服务器去查找数据，如果缓存服务器中没有查到数据，那么就自己去连接数据库，从数据库中去查找数据，同时在返回数据以后，还要把这个数据当作缓存写入到缓存服务器中去，以便于下一次读取的时候从缓存中读取。
3. 缓存虽然对系统性能提升非常明显，但是也还是需要对缓存进行合理的使用，在合适的场景下进行使用。需要关注的是第一是频繁修改的数据，如果一个数据经常被修改，那么使用缓存可能就价值不大；第二是缓存要有热点，因为缓存的空间总是有限的，只能存储一部分数据，如果被访问的数据概率都是一样的，如果没有热点，数据极有可能写入缓存以后很快又被清除掉了，没有被读取过，体现不出来缓存的价值；还有两点需要关注的分别是缓存雪崩和数据的一致性。
4. 分布式对象缓存是我们分布式架构中用的比较多的一种缓存。使用分布式缓存要注意的是：缓存的路由算法是如何实现的？比较重要的、用的比较广泛的是一致性哈希算法。

总之，缓存是无处不在的，在整个计算机系统中，在各个地方，只要你能够想得到的，都可以使用缓存来提升性能，甚至应用程序的一段代码中都可以使用缓存。所以我们多关注缓存的使用，同时也要关注使用缓存的那些注意点。缓存是系统性能优化最重要的手段之一，如果想了解性能优化更多的架构原理和技术方法，见[高性能系统架构设计](2020-06-29-高性能系统架构设计.md)
